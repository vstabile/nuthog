// Import the cashu-ts library
import {
  CashuMint,
  CashuWallet,
  getDecodedToken,
  getEncodedToken,
  getEncodedTokenV4,
} from "@cashu/cashu-ts";
import QRCode from "qrcode";

// Function to generate a random seed phrase
function generateRandomSeedPhrase() {
  // This is just a simulation - in a real app, use a proper BIP-39 library
  const wordList = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
  ];

  // Generate 12 random words from the list
  let seedPhrase = [];
  for (let i = 0; i < 12; i++) {
    const randomIndex = Math.floor(Math.random() * wordList.length);
    seedPhrase.push(wordList[randomIndex]);
  }

  return seedPhrase.join(" ");
}

// Initialize storage with default values if not already set
chrome.runtime.onInstalled.addListener(async () => {
  const data = await chrome.storage.local.get([
    "stats",
    "tokens",
    "settings",
    "processedTokens",
    "wallet",
    "mintProofs",
  ]);

  if (!data.stats) {
    await chrome.storage.local.set({
      stats: { found: 0, claimed: 0, totalValue: 0 },
    });
  }

  if (!data.tokens) {
    await chrome.storage.local.set({
      tokens: [],
    });
  }

  if (!data.settings) {
    await chrome.storage.local.set({
      settings: {
        mintUrl: "https://mint.refugio.com.br",
        notificationsEnabled: true,
        useToastNotifications: true, // Default to using toast notifications
        playSounds: true, // Default to playing sounds
      },
    });
  } else if (data.settings) {
    // Update existing settings with any new options
    const updatedSettings = {
      ...data.settings,
      useToastNotifications:
        data.settings.useToastNotifications !== undefined
          ? data.settings.useToastNotifications
          : true,
      playSounds:
        data.settings.playSounds !== undefined
          ? data.settings.playSounds
          : true,
    };

    // Remove autoSwap if it exists
    if (updatedSettings.autoSwap !== undefined) {
      delete updatedSettings.autoSwap;
    }

    await chrome.storage.local.set({
      settings: updatedSettings,
    });
  }

  if (!data.processedTokens) {
    await chrome.storage.local.set({
      processedTokens: {},
    });
  }

  if (!data.mintProofs) {
    await chrome.storage.local.set({
      mintProofs: {},
    });
  } else if (data.storedProofs) {
    // Migrate from old storedProofs to new mintProofs structure
    // If we have old storedProofs but no mintProofs, create a mintProofs object
    // with the default mint URL
    const mintUrl = data.settings?.mintUrl || "https://mint.refugio.com.br";
    const mintProofs = {
      [mintUrl]: data.storedProofs,
    };

    await chrome.storage.local.set({ mintProofs });
    console.log("Migrated old storedProofs to new mintProofs structure");

    // Optionally, clean up the old storedProofs
    chrome.storage.local.remove(["storedProofs"]);
  }

  // Initialize wallet storage if it doesn't exist
  if (!data.wallet) {
    console.log("No wallet found. Automatically generating a new seed phrase.");

    // Generate a new seed phrase
    const seedPhrase = generateRandomSeedPhrase();

    // Create and save the wallet
    const wallet = {
      seedPhrase: seedPhrase,
      createdAt: Date.now(),
      autoGenerated: true,
    };

    await chrome.storage.local.set({ wallet });
    console.log("New wallet automatically generated with seed phrase.");
  }
});

// Function to show toast notification in active tab
async function showToastNotification(
  title,
  message,
  type = "info",
  playSounds = true,
  duration = 7000
) {
  try {
    // Get active tab
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
    if (tabs.length === 0) {
      console.log("No active tab found to show toast notification");

      // Fall back to system notification
      const notificationOptions = {
        type: "basic",
        iconUrl: "icons/icon128.png",
        title: title,
        message: message,
      };

      chrome.notifications.create(
        "token-notification-" + Date.now(),
        notificationOptions
      );

      return;
    }

    // Try to send message to content script
    try {
      await chrome.tabs.sendMessage(tabs[0].id, {
        action: "showToast",
        title: title,
        message: message,
        type: type,
        duration: duration,
        playSound: playSounds,
      });

      console.log("Toast notification sent to tab:", tabs[0].id);
    } catch (error) {
      console.error("Error sending toast to tab:", error);

      // Fall back to system notification if content script communication fails
      const notificationOptions = {
        type: "basic",
        iconUrl: "icons/icon128.png",
        title: title,
        message: message,
      };

      chrome.notifications.create(
        "token-notification-" + Date.now(),
        notificationOptions
      );
    }
  } catch (error) {
    console.error("Error showing toast notification:", error);

    // Last resort fallback to system notification
    try {
      const notificationOptions = {
        type: "basic",
        iconUrl: "icons/icon128.png",
        title: title,
        message: message,
      };

      chrome.notifications.create(
        "token-notification-" + Date.now(),
        notificationOptions
      );
    } catch (finalError) {
      console.error("Failed to show any notification:", finalError);
    }
  }
}

// Function to show notification (either toast or system)
async function showNotification(title, message, type = "info") {
  const { settings } = await chrome.storage.local.get(["settings"]);

  // Default to toast notifications if setting is not specified
  const useToast = settings?.useToastNotifications !== false;
  const playSounds = settings?.playSounds !== false;

  if (useToast) {
    try {
      // Use custom toast notification with default duration of 7000ms
      await showToastNotification(title, message, type, playSounds);
    } catch (error) {
      console.error(
        "Toast notification failed, falling back to system notification:",
        error
      );
      // Fallback to system notification if toast fails
      const notificationOptions = {
        type: "basic",
        iconUrl: "icons/icon128.png",
        title: title,
        message: message,
      };

      chrome.notifications.create(
        "token-notification-" + Date.now(),
        notificationOptions
      );
    }
  } else {
    // Use standard Chrome notification
    const notificationOptions = {
      type: "basic",
      iconUrl: "icons/icon128.png",
      title: title,
      message: message,
    };

    chrome.notifications.create(
      "token-notification-" + Date.now(),
      notificationOptions
    );
  }
}

// Show token notification
function showTokenNotification(tokenInfo) {
  const title = "NutHog: Cashu Nut Found!";
  const message = tokenInfo.claimed
    ? `Oink oink! Successfully sniffed out and collected a tasty ${tokenInfo.value} sats nut. It's safely in your basket now!`
    : `Oink! Found a delicious nut worth approximately ${tokenInfo.value} sats, but couldn't collect it this time.`;
  const type = tokenInfo.claimed ? "success" : "info";

  showNotification(title, message, type);
}

// Listen for messages from content script and popup
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === "emojiDetected") {
    console.log("Emoji detected:", message.emoji);
    processToken({
      type: "emoji",
      token: message.decoded,
      emoji: message.emoji,
      url: message.url,
      tabId: sender.tab.id,
    });
    return true; // Indicates async response
  } else if (message.action === "cashuTokenDetected") {
    console.log(
      "Plain Cashu token detected:",
      message.token.substring(0, 20) + "..."
    );
    processToken({
      type: "plain",
      token: message.token,
      url: message.url,
      tabId: sender.tab.id,
    });
    return true; // Indicates async response
  } else if (message.action === "settingsUpdated") {
    console.log("Settings updated:", message.settings);
    // You might want to reinitialize the wallet with new settings
    return true;
  } else if (message.action === "walletUpdated") {
    console.log("Wallet updated");
    // Handle wallet update if needed
    return true;
  } else if (message.action === "serializeProofs") {
    console.log("Serializing proofs for mint:", message.mintUrl);
    console.log("Number of proofs:", message.proofs.length);

    // Ensure we have a valid mint URL
    if (!message.mintUrl) {
      console.error("No mint URL provided for serializing proofs");
      sendResponse({
        success: false,
        error: "No mint URL provided",
      });
      return true;
    }

    const mint = new CashuMint(message.mintUrl);
    const wallet = new CashuWallet(mint);

    // Load the mint's keysets before using the wallet
    wallet
      .loadMint()
      .then(async () => {
        console.log("Mint loaded successfully");
        // Calculate total amount
        const totalAmount = message.proofs.reduce(
          (total, proof) => total + proof.amount,
          0
        );
        console.log("Total amount:", totalAmount);

        try {
          const { keep, send } = await wallet.send(totalAmount, message.proofs);
          console.log("Wallet send completed. Proofs to send:", send.length);

          const token = {
            mint: message.mintUrl,
            proofs: send,
          };

          const encodedToken = getEncodedTokenV4(token);
          console.log(
            "Token encoded successfully:",
            encodedToken.substring(0, 20) + "..."
          );

          // Store the spent token in storage
          const timestamp = new Date().toISOString();
          const spentToken = {
            token: encodedToken,
            mint: message.mintUrl,
            amount: totalAmount,
            timestamp: timestamp,
          };

          // Get existing spent tokens
          chrome.storage.local.get(
            ["spentTokens", "mintProofs"],
            function (data) {
              const spentTokens = data.spentTokens || [];
              const mintProofs = data.mintProofs || {};

              // Add the new spent token
              spentTokens.push(spentToken);

              // Remove the spent proofs from mintProofs
              if (mintProofs[message.mintUrl]) {
                console.log(
                  "Current proofs for mint:",
                  mintProofs[message.mintUrl].length
                );

                // Log the proof IDs we're trying to remove
                const proofIds = message.proofs.map((p) => p.id);
                console.log("Proof IDs to remove:", proofIds);

                // Create a map of proof IDs to easily identify which proofs to remove
                const proofIdsToRemove = new Set(proofIds);

                // Filter out the spent proofs
                const remainingProofs = mintProofs[message.mintUrl].filter(
                  (proof) => {
                    const shouldKeep = !proofIdsToRemove.has(proof.id);
                    if (!shouldKeep) {
                      console.log("Removing proof with ID:", proof.id);
                    }
                    return shouldKeep;
                  }
                );

                console.log(
                  "Remaining proofs after filtering:",
                  remainingProofs.length
                );
                mintProofs[message.mintUrl] = remainingProofs;

                // If no proofs left for this mint, remove the mint entry
                if (mintProofs[message.mintUrl].length === 0) {
                  console.log("No proofs left for mint, removing mint entry");
                  delete mintProofs[message.mintUrl];
                }
              } else {
                console.log("No proofs found for mint:", message.mintUrl);
              }

              // Save the updated data
              chrome.storage.local.set(
                {
                  spentTokens: spentTokens,
                  mintProofs: mintProofs,
                },
                function () {
                  console.log("Spent token saved and proofs removed");
                }
              );
            }
          );

          // Send the serialized token back to the popup
          console.log("Sending response back to popup");
          sendResponse({
            success: true,
            token: encodedToken,
            amount: totalAmount,
          });
          console.log("Response sent");
        } catch (error) {
          console.error("Error in wallet.send:", error);
          sendResponse({
            success: false,
            error: error.message || "Error creating token",
          });
        }
      })
      .catch((error) => {
        console.error("Error loading mint:", error);
        sendResponse({
          success: false,
          error: error.message || "Error loading mint",
        });
      });

    return true;
  } else if (message.action === "generateQRCode") {
    console.log(
      "Generating QR code for data:",
      message.data.substring(0, 20) + "..."
    );

    try {
      // Use the string method instead of toDataURL to avoid canvas requirement
      QRCode.toString(
        message.data,
        {
          type: "svg",
          width: 200,
          margin: 1,
          color: {
            dark: "#8b5a2b",
            light: "#ffffff",
          },
        },
        (err, svgString) => {
          if (err) {
            console.error("Error generating QR code:", err);
            sendResponse({
              success: false,
              error: err.message,
            });
          } else {
            console.log("QR code generated successfully");
            // Convert SVG string to data URL
            const dataUrl =
              "data:image/svg+xml;charset=utf-8," +
              encodeURIComponent(svgString);
            console.log("Sending QR code response back to popup");
            sendResponse({
              success: true,
              dataUrl: dataUrl,
              svgString: svgString,
            });
            console.log("QR code response sent");
          }
        }
      );

      return true; // Indicates async response
    } catch (error) {
      console.error("Error generating QR code:", error);
      sendResponse({
        success: false,
        error: error.message,
      });
      return false;
    }
  }
});

// Process a token (either plain Cashu token or emoji-encoded token)
async function processToken(tokenData) {
  try {
    const { type, token, emoji, url, tabId } = tokenData;

    // Log the token type being processing
    console.log(`Processing ${type} token: ${token.substring(0, 20)}...`);

    // Get the list of already processed tokens to avoid duplicates
    const { processedTokens, settings } = await chrome.storage.local.get([
      "processedTokens",
      "settings",
    ]);

    // Check if we've already processed this token
    // if (processedTokens[token]) {
    //   console.log("Token already processed:", token.substring(0, 20) + "...");
    //   return;
    // }

    // Validate token format before attempting to decode
    if (!isValidCashuToken(token)) {
      console.warn(
        "Invalid token format detected:",
        token.substring(0, 20) + "..."
      );
      return;
    }

    // Try to decode the token using cashu-ts
    let decodedToken;
    try {
      console.log(
        "Attempting to decode token:",
        token.substring(0, 20) + "..."
      );
      decodedToken = getDecodedToken(token);
      console.log("Token decoded successfully");
    } catch (error) {
      console.error("Error decoding token with cashu-ts:", error);
      console.error(
        "Token that caused the error:",
        token.substring(0, 50) + (token.length > 50 ? "..." : "")
      );
      return;
    }

    if (!decodedToken) {
      console.log("Not a valid Cashu token");
      return;
    }

    console.log("Valid Cashu token found:", decodedToken);

    // Mark this token as processed to avoid duplicates
    processedTokens[token] = {
      timestamp: Date.now(),
      url: url,
    };

    await chrome.storage.local.set({ processedTokens });

    // Update found count in stats
    const { stats, tokens, mintProofs } = await chrome.storage.local.get([
      "stats",
      "tokens",
      "mintProofs",
    ]);
    stats.found += 1;

    // Initialize mintProofs if it doesn't exist
    const proofsByMint = mintProofs || {};

    // Extract the mint URL from the token if available
    let tokenMintUrl = null;

    // Check if the token has a mint property
    if (decodedToken && decodedToken.token) {
      // For newer token formats
      if (Array.isArray(decodedToken.token) && decodedToken.token.length > 0) {
        tokenMintUrl = decodedToken.token[0].mint;
      }
      // For older token formats
      else if (
        typeof decodedToken.token === "object" &&
        decodedToken.token.mint
      ) {
        tokenMintUrl = decodedToken.token.mint;
      }
    }
    // For tokens with direct mint property
    else if (decodedToken && decodedToken.mint) {
      tokenMintUrl = decodedToken.mint;
    }

    console.log("Token mint URL:", tokenMintUrl);

    // Use the mint URL from the token if available, otherwise fall back to settings
    const mintUrl = tokenMintUrl || settings.mintUrl;
    console.log("Using mint URL:", mintUrl);

    // Initialize the wallet with the mint URL from the token or settings
    try {
      const mint = new CashuMint(mintUrl);
      const wallet = new CashuWallet(mint);

      // Load the mint's keysets before using the wallet
      try {
        await wallet.loadMint();
        console.log("Mint loaded successfully, keysets:", wallet.keysets);
      } catch (mintError) {
        console.error("Error loading mint:", mintError);
        showNotification(
          "NutHog: Mint Error",
          `Could not load mint at ${mintUrl}. Please check if this mint is available.`,
          "error"
        );
        return;
      }

      // Try to claim the token
      let claimResult;
      let tokenValue = 0;

      try {
        // Receive the token
        console.log("Attempting to receive token...");
        const receiveResult = await wallet.receive(token);
        console.log("Token received:", receiveResult);

        // Check if we have a valid result (should be an array of Proof objects)
        if (
          receiveResult &&
          (Array.isArray(receiveResult) || receiveResult.token)
        ) {
          // Calculate the token value
          tokenValue = calculateTokenValue(receiveResult);
          console.log("Token value:", tokenValue);

          // Store the received proofs locally, organized by mint URL
          console.log("Storing proofs for mint:", mintUrl);

          // Initialize array for this mint if it doesn't exist
          if (!proofsByMint[mintUrl]) {
            proofsByMint[mintUrl] = [];
          }

          // Add the new proofs to the array
          if (Array.isArray(receiveResult)) {
            proofsByMint[mintUrl] = [
              ...proofsByMint[mintUrl],
              ...receiveResult,
            ];
          } else if (receiveResult.token) {
            // Handle the new token format
            receiveResult.token.forEach((t) => {
              if (t.proofs && Array.isArray(t.proofs)) {
                proofsByMint[mintUrl] = [...proofsByMint[mintUrl], ...t.proofs];
              }
            });
          }

          // Save the updated proofs
          await chrome.storage.local.set({ mintProofs: proofsByMint });
          console.log("Proofs stored successfully");

          // Update claimed count in stats
          stats.claimed += 1;
          stats.totalValue += tokenValue;

          // Create token record for successfully claimed tokens
          const tokenRecord = {
            timestamp: Date.now(),
            url: url,
            value: tokenValue,
            claimed: true,
            mintUrl: mintUrl,
            type: type,
          };

          // Add type-specific properties
          if (type === "emoji") {
            tokenRecord.emoji = emoji;
            tokenRecord.decoded = token.substring(0, 50) + "...";
          } else {
            tokenRecord.token = token.substring(0, 50) + "...";
          }

          // Add to beginning of array
          tokens.unshift(tokenRecord);

          // Keep only the last 100 tokens
          if (tokens.length > 100) {
            tokens.pop();
          }

          // Save the updated tokens array
          await chrome.storage.local.set({ tokens });

          // Show success notification
          showTokenNotification({
            value: tokenValue,
            claimed: true,
          });
        } else {
          console.warn("Unexpected receive result format:", receiveResult);

          // Only show notification for failed attempt, don't save to history
          showTokenNotification({
            value: estimateTokenValue(decodedToken),
            claimed: false,
          });
        }
      } catch (error) {
        console.error("Error claiming token:", error);

        // Check for specific keyset error
        if (
          error.message &&
          error.message.includes("No keyset found with id")
        ) {
          const keysetId =
            error.message.match(/id: ([a-f0-9]+)/)?.[1] || "unknown";
          console.log(
            `Token uses keyset ID ${keysetId} which is not available on mint ${mintUrl}`
          );

          // Show a more informative notification
          showNotification(
            "NutHog: Token Incompatible",
            `This token was created with a different mint or keyset (${keysetId}) that is not supported by your current mint. Try changing your mint URL in settings.`,
            "warning"
          );
        } else {
          // Show generic error notification for failed attempt, don't save to history
          showTokenNotification({
            value: estimateTokenValue(decodedToken),
            claimed: false,
          });
        }
      }

      // Update stats
      await chrome.storage.local.set({ stats });

      // Update any open popup with the latest stats and tokens
      chrome.runtime.sendMessage({
        action: "updateStats",
        stats: stats,
        tokens: tokens,
      });
    } catch (error) {
      console.error("Error initializing wallet:", error);
    }
  } catch (error) {
    console.error("Error processing token:", error);
  }
}

// Calculate the total value of a token from the receive result
function calculateTokenValue(receiveResult) {
  let totalValue = 0;

  receiveResult.forEach((proof) => {
    if (proof && typeof proof.amount === "number") {
      totalValue += proof.amount;
    }
  });
  return totalValue;
}

// Estimate token value from decoded token (without claiming)
function estimateTokenValue(decodedToken) {
  let totalValue = 0;

  try {
    // If decodedToken is an array of Proof objects, sum their amounts directly
    if (Array.isArray(decodedToken)) {
      decodedToken.forEach((proof) => {
        if (proof && typeof proof.amount === "number") {
          totalValue += proof.amount;
        }
      });
      return totalValue;
    }

    // Handle token structure according to Cashu-ts documentation
    if (decodedToken && decodedToken.token) {
      // If token is an array, process each entry
      if (Array.isArray(decodedToken.token)) {
        decodedToken.token.forEach((t) => {
          // If proofs array exists, sum the amounts
          if (t.proofs && Array.isArray(t.proofs)) {
            t.proofs.forEach((proof) => {
              if (proof.amount) {
                totalValue += parseInt(proof.amount, 10);
              }
            });
          }
        });
      }
    }
  } catch (error) {
    console.error("Error estimating token value:", error);
  }

  return totalValue;
}

// Function to check if a token has valid Cashu format
function isValidCashuToken(decoded) {
  try {
    // Check if it starts with "cashu"
    if (!decoded || !decoded.startsWith("cashu")) {
      return false;
    }

    // Check if it has a reasonable length
    if (decoded.length < 10 || decoded.length > 10000) {
      console.warn("Suspicious token length:", decoded.length);
      return false;
    }

    // Extract the part after "cashu"
    const tokenPart = decoded.substring(5);

    // Check if it contains only valid base64url characters
    const base64urlRegex = /^[A-Za-z0-9\-_]+$/;
    if (!base64urlRegex.test(tokenPart)) {
      console.warn("Token contains invalid characters for base64url encoding");
      return false;
    }

    // We're not requiring JSON parsing anymore as some valid tokens
    // may use different encoding formats

    return true;
  } catch (error) {
    console.error("Error validating Cashu token:", error);
    return false;
  }
}
